[![hits](https://hits.deltapapa.io/github/vskurikhin/otus-highload-architect-2021-03-VSkurikhin.svg)](https://hits.deltapapa.io)

# Лекции

## TOC

- [Лекции](lectures.md)
  1. [Проблемы высоких нагрузок](lectures.md#проблемы-высоких-нагрузок)
     - [Особенности работы операционной системы • Модели веб-серверов](lectures.md#особенности-работы-операционной-системы-•-модели-веб-серверов)
     - [Возможности языковых платформ](lectures.md#возможности-языковых-платформ)
     - [Трехзвенная архитектура](lectures.md#трехзвенная-архитектура)
     - [Полезные ссылки](lectures.md#полезные-ссылки)

### [Проблемы высоких нагрузок](https://otus.ru/lessons/highloadarchitect/?int_source=courses_catalog&int_term=programming)

#### Особенности работы операционной системы • Модели веб-серверов

##### Стандартный сценарий

Имеется компьютер с одним 4-хядерным процессором, на котором запущены: chrome, skype, zoom, telegram, slack, ... Как это вяжется с представлением о том, что на одном ядре выполняется 1 программа?

##### Передача управления

Операционная система выделяет для выполнения программы квант времени (~50 мкс), затем происходит прерывание и переключение контекста. Переключение контекста происходит и при любом системном вызове.

##### Переключение контекста (context switch)

Сохранение:
- Регистров процессора
- Общей информации: pid, tid, uid, gid, euid, egid, ...
- Состояния процесса/потока
- Прав доступа
- Используемых потоком ресурсов и блокировок
- Счетчиков использованных ресурсов (например, таймеров процессорного времени)
- Регионов памяти, выделенных процессу

Очистка:
- Конвейера команд и данных процессора
- TLB, отвечающего за страничное отображение линейных адресов на физические

Вывод: переключение контекста – дорогая операция (~1 мкс, тогда как выполнение простой строчки кода занимает ~0.5 нс)

##### Процессы и потоки

- В Linux практически одно и тоже
- Потоки имеют общую память

Какими системными вызовами создаются потоки и процессы?
- clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fa001a93a10) = 6916 [fork()]
- clone(child_stack=0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SYSVSEM|CLONE _SIGHAND|CLONE_THREAD|CLONE_SETTLS|CLONE_PARENT_S child_tidptr=0x7fa001a93a10) = 6916 [pthread_create()]

##### strace

Позволяет трассировать процесс и наблюдать выполняемые им системные вызовы.

##### Память

- Память разбивается на однотипные куски одинакового размера 4 кБ (иногда 4 МБ)
- Аллокация памяти происходит при первом обращении
- Со включенным режимом swap возможна подкачка памяти с HDD (на проде желательно выключать)

##### Кейсы

- Процессиспользует1Тбпамяти,намашине4ГбОЗУ.Чтопроизойдет?
- Код занимает 1 Мб, данные 1 Мб. Сколько нужно памяти после fork’а?
- А после изменения данных?
- Redis работает на машине со включенным huge-pages в персистентном режиме. При этом иногда тормозит. Почему?

##### Модели веб-серверов

- Worker(многопоточный)
- Prefork (многопроцессный) • Асинхронный
- Комбинированный 

##### Worker vs prefork

- Потокиэкономятпамять
- Переключать потоки дешевле
- Потокисложнеесинхронизировать

##### Worker и prefork

Преимущества:
- Простота

Недостатки:
- Неэффективность при интенсивной работе с I/O (увеличение числа обработчиков – не вариант)
- Ограниченность размером пула числа клиентов, обслуживаемых одновременно
- Дороговизна выделения по обработчику на каждого клиента

##### Асинхронный веб-сервер

- Основан на однопоточном событийном цикле и шаблоне «reactor»
- Цикл событий читает события, представленные в виде callback’ов, из очереди с приоритетом (приоритет – время готовности)
- Клиентский код, инициируя операцию I/O, регистрирует callback в очереди
- Цикл событий опрашивает дескрипторы, ожидающие I/O, обновляет приоритеты в очереди
- В конце callback’а возвращаем управление циклу событий

Преимущества:
- Можно обрабатывать одновременно большое количество клиентов
- Отсутствуетпереключениеконтекста

Недостатки:
- Потребляетнебольшеодногопроцессорногоядра(лечится применением комбинированной модели)
- Клиенты связаны одним потоком (утечки памяти, блокировки, ошибки, действия, нагружающие процессор недопустимы)
- Код становится сложнее

##### Комбинированный веб-сервер

- Имеетпулпроцессов,каждыйизкоторыхзапускаетпулпотоков, каждый из которых использует модель обработки на основе асинхронного ввода-вывода
- Применяется в реальных серверах (nginx и apache http server в режиме MPM event)



#### Возможности языковых платформ

##### Дальнейшее развитие

Асинхронный код:
- Быстрый
- Потребляетмалопамяти
- Сложно писать 

Синхронный код:
- Медленный
- Потребляетмногопамяти
- Просто писать

Соединим концепции на уровне языковых платформ или библиотек (fibers, green threads, goroutines).

##### Концепция fiber’ов

- Совмещаемплюсысинхроннойиасинхронноймодели
- Пишем свой более легковесный планировщик (программа будет иметь линейный вид)
- Оставляем машину событий (получаем быстродействие)

##### Perl

- Обычно работает внутри apache
- Синхронный язык с поддержкой thread’ов (редко)
- Есть библиотека AnyEvent
- Есть библиотека для fiber’ов
- Да,онвсеещежив

##### python

- Есть потоки
- Есть fiber
- Процесс с потоками в python может использовать 1 ядро (GIL)

##### NodeJS

- Синхронный код
- Строго однопоточный
- Надо поднимать много процессов 
- Сложно писать

##### Go

- Концепциязеленыхпотоков
- Умеет использовать столько ядер CPU, сколько нужно • Ориентированнамикросервисы
- Быстрый

#### Трехзвенная архитектура

#### Полезные ссылки
| Название | Дата |
| -------- | ---- |
| [1. Что такое «асинхронная событийная модель», и почему сейчас она «в моде»](https://habr.com/ru/post/128772/) | 2011-09-20 |
| [2. Is this explanation about VSS/RSS/PSS/USS accurate?](https://stackoverflow.com/questions/22372960/is-this-explanation-about-vss-rss-pss-uss-accurate) | 2017-04-30 |
| [3. Node.js multithreading: What are Worker threads, and why do they matter?](https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/) | 2019-01-31 |
